!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("three")):"function"==typeof define&&define.amd?define(["three"],e):"object"==typeof exports?exports.ThickLine=e(require("three")):t.ThickLine=e(t.THREE)}(self,(function(t){return(()=>{"use strict";var e={986:(t,e,n)=>{n.r(e),n.d(e,{ThickLine:()=>v,ThickLineGeometry:()=>j,ThickLineMaterial:()=>z,ThickLineSegments:()=>h,ThickLineSegmentsGeometry:()=>I});var r,o=n(815),i=(r=function(t,e){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])})(t,e)},function(t,e){function n(){this.constructor=t}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)}),a=new o.Vector3,s=new o.Vector3,c=new o.Vector4,u=new o.Vector4,f=new o.Vector4,p=new o.Vector3,l=new o.Matrix4,d=new o.Line3,m=new o.Vector3,h=function(t){function e(e,n){var r=t.call(this,e,n)||this;return r.type="ThickLineSegments",r}return i(e,t),e.prototype.computeLineDistances=function(){for(var t=this.geometry,e=t.attributes,n=e.aInstanceStart,r=e.aInstanceEnd,i=n.data.count,c=new Float32Array(2*i),u=0,f=0,p=i;u<p;u++,f+=2)a.fromBufferAttribute(n,u),s.fromBufferAttribute(r,u),c[f]=0===f?0:c[f-1],c[f+1]=c[f]+a.distanceTo(s);var l=new o.InstancedInterleavedBuffer(c,2,1);return t.setAttribute("aInstanceDistanceStart",new o.InterleavedBufferAttribute(l,1,0)),t.setAttribute("aInstanceDistanceEnd",new o.InterleavedBufferAttribute(l,1,1)),this},e.prototype.raycast=function(t,e){null===t.camera&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');var n=void 0!==t.params.Line&&t.params.Line.threshold||0,r=t.ray,i=t.camera,a=i.projectionMatrix,s=this.geometry,h=this.material,y=h.resolution,v=h.linewidth+n,g=s.attributes,b=g.aInstanceStart,S=g.aInstanceEnd,x=-i.near;r.at(1,f),f.w=1,f.applyMatrix4(i.matrixWorldInverse),f.applyMatrix4(a),f.multiplyScalar(1/f.w),f.x*=y.x/2,f.y*=y.y/2,f.z=0,p.copy(f);var _=this.matrixWorld;l.multiplyMatrices(i.matrixWorldInverse,_);for(var w=0,I=b.count;w<I;w++)if(c.fromBufferAttribute(b,w),u.fromBufferAttribute(S,w),c.w=1,u.w=1,c.applyMatrix4(l),u.applyMatrix4(l),!(c.z>x&&u.z>x)){if(c.z>x){var O=c.z-u.z,j=(c.z-x)/O;c.lerp(u,j)}else u.z>x&&(O=u.z-c.z,j=(u.z-x)/O,u.lerp(c,j));c.applyMatrix4(a),u.applyMatrix4(a),c.multiplyScalar(1/c.w),u.multiplyScalar(1/u.w),c.x*=y.x/2,c.y*=y.y/2,u.x*=y.x/2,u.y*=y.y/2,d.start.copy(c),d.start.z=0,d.end.copy(u),d.end.z=0;var P=d.closestPointToPointParameter(p,!0);d.at(P,m);var B=o.MathUtils.lerp(c.z,u.z,P),A=B>=-1&&B<=1,C=p.distanceTo(m)<.5*v;if(A&&C){d.start.fromBufferAttribute(b,w),d.end.fromBufferAttribute(S,w),d.start.applyMatrix4(_),d.end.applyMatrix4(_);var L=new o.Vector3,z=new o.Vector3;r.distanceSqToSegment(d.start,d.end,z,L),e.push({point:z,pointOnLine:L,distance:r.origin.distanceTo(z),object:this,face:null,faceIndex:w,uv2:null})}}},e}(o.Mesh),y=function(){var t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])})(e,n)};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}(),v=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.type="ThickLine",e}return y(e,t),e}(h),g=function(){var t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])})(e,n)};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}(),b=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],S=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],x=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5],_=new o.Vector3,w=new o.Box3,I=function(t){function e(){var e=t.call(this)||this;return e.type="ThickLineSegmentsGeometry",e.setIndex(x),e.setAttribute("position",new o.Float32BufferAttribute(b,3)),e.setAttribute("uv",new o.Float32BufferAttribute(S,2)),e}return g(e,t),e.prototype.setColors=function(t){var e=t instanceof Float32Array?t:new Float32Array(t),n=new o.InstancedInterleavedBuffer(e,6,1);return this.setAttribute("aInstanceColorStart",new o.InterleavedBufferAttribute(n,3,0)),this.setAttribute("aInstanceColorEnd",new o.InterleavedBufferAttribute(n,3,3)),this},e.prototype.setPositions=function(t){for(var e=t instanceof Float32Array?t:new Float32Array(t),n=new o.InstancedInterleavedBuffer(e,6,1),r=t.length/3,i=new Float32Array(r),a=0;a<r;)i[a]=a++;return this.setAttribute("aInstanceStart",new o.InterleavedBufferAttribute(n,3,0)),this.setAttribute("aInstanceEnd",new o.InterleavedBufferAttribute(n,3,3)),this.setAttribute("aInstanceSegmentIndex",new o.InstancedBufferAttribute(i,1)),this.computeBoundingBox(),this.computeBoundingSphere(),this},e.prototype.applyMatrix=function(t){return this.applyMatrix4(t)},e.prototype.applyMatrix4=function(t){var e=this.attributes.instanceStart,n=this.attributes.instanceEnd;return void 0!==e&&(e.applyMatrix4(t),n.applyMatrix4(t),e.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},e.prototype.computeBoundingSphere=function(){null===this.boundingSphere&&(this.boundingSphere=new o.Sphere),null===this.boundingBox&&this.computeBoundingBox();var t=this.attributes.instanceStart,e=this.attributes.instanceEnd;if(void 0!==t&&void 0!==e){var n=this.boundingSphere.center;this.boundingBox.getCenter(n);for(var r=0,i=0,a=t.count;i<a;i++)_.fromBufferAttribute(t,i),r=Math.max(r,n.distanceToSquared(_)),_.fromBufferAttribute(e,i),r=Math.max(r,n.distanceToSquared(_));this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}},e.prototype.computeBoundingBox=function(){null===this.boundingBox&&(this.boundingBox=new o.Box3);var t=this.attributes.instanceStart,e=this.attributes.instanceEnd;void 0!==t&&void 0!==e&&(this.boundingBox.setFromBufferAttribute(t),w.setFromBufferAttribute(e),this.boundingBox.union(w))},e.prototype.fromWireframeGeometry=function(t){return this.setPositions(t.attributes.position.array),this},e.prototype.fromEdgesGeometry=function(t){return this.fromWireframeGeometry(t)},e.prototype.fromMesh=function(t){return this.fromWireframeGeometry(new o.WireframeGeometry(t.geometry)),this},e.prototype.fromLineSegments=function(t){return this.fromWireframeGeometry(t.geometry)},e}(o.InstancedBufferGeometry),O=function(){var t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])})(e,n)};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}(),j=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.type="ThickLineGeometry",e}return O(e,t),e.prototype.setPositions=function(e){for(var n=e.length-3,r=new Float32Array(2*n),o=0;o<n;o+=3)r[2*o]=e[o],r[2*o+1]=e[o+1],r[2*o+2]=e[o+2],r[2*o+3]=e[o+3],r[2*o+4]=e[o+4],r[2*o+5]=e[o+5];return t.prototype.setPositions.call(this,r),this},e.prototype.setColors=function(e){for(var n=e.length-3,r=new Float32Array(2*n),o=0;o<n;o+=3)r[2*o]=e[o],r[2*o+1]=e[o+1],r[2*o+2]=e[o+2],r[2*o+3]=e[o+3],r[2*o+4]=e[o+4],r[2*o+5]=e[o+5];return t.prototype.setColors.call(this,r),this},e.prototype.fromLine=function(t){var e=t.geometry;return e instanceof o.BufferGeometry&&this.setPositions(e.attributes.position.array),this},e.prototype.copy=function(){return this},e}(I),P=n(12),B=n(817),A=function(){var t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])})(e,n)};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}(),C=function(){return(C=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var o in e=arguments[n])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)},L=o.UniformsUtils.merge([o.UniformsLib.common,o.UniformsLib.fog,{uLinewidth:{value:1},uResolution:{value:new o.Vector2(1,1)},uDashScale:{value:1},uDashSize:{value:1},uDashOffset:{value:0},uGapSize:{value:1}}]),z=function(t){function e(e){var n=t.call(this,{vertexShader:P,fragmentShader:B,uniforms:o.UniformsUtils.clone(L),clipping:!0})||this;return n.type="ThickLineMaterial",n.dashed=!1,n._customChunks={},n._customUniforms={},n._chunkReplacer=function(t,e){var r;return n._parseChunks(null!==(r=n._customChunks[e])&&void 0!==r?r:"")},n.setValues(e),n.onBeforeCompile=function(t){t.uniforms=C(C({},t.uniforms),n._customUniforms),t.vertexShader=n._parseChunks(t.vertexShader),t.fragmentShader=n._parseChunks(t.fragmentShader)},n}return A(e,t),Object.defineProperty(e.prototype,"resolution",{get:function(){return this.uniforms.uResolution.value},set:function(t){this.uniforms.uResolution.value=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"opacity",{get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms&&(this.uniforms.opacity.value=t)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"gapSize",{get:function(){return this.uniforms.uGapSize.value},set:function(t){this.uniforms.uGapSize.value=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"dashOffset",{get:function(){return this.uniforms.uDashOffset.value},set:function(t){this.uniforms.uDashOffset.value=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"dashSize",{get:function(){return this.uniforms.uDashSize.value},set:function(t){this.uniforms.uDashSize.value=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"dashScale",{get:function(){return this.uniforms.uDashScale.value},set:function(t){this.uniforms.uDashScale.value=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"linewidth",{get:function(){return this.uniforms.uLinewidth.value},set:function(t){this.uniforms&&this.uniforms.uLinewidth&&(this.uniforms.uLinewidth.value=t)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"color",{get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t},enumerable:!1,configurable:!0}),e.prototype.setUniforms=function(t){this._customUniforms=t,this.needsUpdate=!0},e.prototype.unsetUniforms=function(){this._customUniforms={},this.needsUpdate=!0},e.prototype.setChunk=function(t,n){e.CustomChunks[t]&&(this._customChunks[t]=n,this.needsUpdate=!0)},e.prototype.unsetChunk=function(t){e.CustomChunks[t]&&(delete this._customChunks[t],this.needsUpdate=!0)},e.prototype.clearChunks=function(){this._customChunks={},this.needsUpdate=!0},e.prototype._parseChunks=function(t){return t.replace(/%- ([\w\d/]+) -%/gm,this._chunkReplacer)},e.CustomChunks={cLocalSpace:!0,cViewSpace:!0,cProjectedSpace:!0,cVertexGlobal:!0,cVertexStart:!0,cVertexEnd:!0,cColor:!0,cFragmentGlobal:!0,cFragmentStart:!0,cFragmentEnd:!0},e.CustomChunkNames=Object.keys(e.CustomChunks),e}(o.ShaderMaterial)},817:t=>{t.exports="uniform vec3 diffuse;\r\nuniform float opacity;\r\n#ifdef USE_DASH\r\n  uniform float uDashSize;\r\n  uniform float uDashOffset;\r\n  uniform float uGapSize;\r\n#endif\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvarying vec2 vUv;\r\nvarying float vInstanceSegmentIndex;\r\n\r\n%- cFragmentGlobal -%\r\n\r\nvec4 transformColor( inout vec4 color ){\r\n  %- cColor -%\r\n  return color;\r\n}\r\n\r\nvoid main() {\r\n\r\n  %- cFragmentStart -%\r\n\r\n  #include <clipping_planes_fragment>\r\n  #ifdef USE_DASH\r\n    if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\r\n    if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\r\n  #endif\r\n  if ( abs( vUv.y ) > 1.0 ) {\r\n    float a = vUv.x;\r\n    float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\r\n    float len2 = a * a + b * b;\r\n    if ( len2 > 1.0 ) discard;\r\n  }\r\n  vec4 diffuseColor = vec4( diffuse, opacity );\r\n  #include <logdepthbuf_fragment>\r\n  #include <color_fragment>\r\n  gl_FragColor = transformColor( diffuseColor );\r\n  #include <tonemapping_fragment>\r\n  #include <encodings_fragment>\r\n  #include <fog_fragment>\r\n  #include <premultiplied_alpha_fragment>\r\n \r\n  %- cFragmentEnd -%\r\n\r\n}"},12:t=>{t.exports="#include <common>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nuniform float uLinewidth;\r\nuniform vec2 uResolution; // TODO: change to (aspect, 1/uResolution.y)\r\n\r\nattribute vec3 aInstanceStart;\r\nattribute vec3 aInstanceEnd;\r\nattribute vec3 aInstanceColorStart;\r\nattribute vec3 aInstanceColorEnd;\r\nattribute float aInstanceSegmentIndex;\r\n\r\nvarying vec2 vUv;\r\nvarying float vInstanceSegmentIndex;\r\n\r\n#ifdef USE_DASH\r\n\tuniform float dashScale;\r\n\tattribute float instanceDistanceStart;\r\n\tattribute float instanceDistanceEnd;\r\n\tvarying float vLineDistance;\r\n#endif\r\n\r\nvoid trimSegment( const in vec4 start, inout vec4 end ) {\r\n\t// trim end segment so it terminates between the camera plane and the near plane\r\n\t// conservative estimate of the near plane\r\n\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\r\n\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\r\n\tfloat nearEstimate = - 0.5 * b / a;\r\n\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\r\n\tend.xyz = mix( start.xyz, end.xyz, alpha );\r\n}\r\n\r\nvec3 transformLocalPosition( const in vec3 _position , const in float segmentIndex ) {\r\n\tvec3 position = _position;\r\n\t%- cLocalSpace -%\r\n\treturn position;\r\n}\r\n\r\nvec4 transformViewPosition( const in vec4 _position , const in float segmentIndex ) {\r\n\tvec3 position = _position.xyz;\r\n\t%- cViewSpace -%\r\n\treturn vec4(position , _position.w);\r\n}\r\n\r\nvec4 transformProjectedPosition( const in vec4 _position , const in float segmentIndex ) {\r\n\tvec4 position = _position;\r\n\t%- cProjectedSpace -%\r\n\treturn position;\r\n}\r\n\r\n%- cVertexGlobal -%\r\n\r\nvoid main() {\r\n\t\r\n\t%- cVertexStart -%\r\n\t\r\n\tbool isStart = position.y < 0.5;\r\n\r\n\t#ifdef USE_COLOR\r\n\t\tvColor.xyz = ( isStart ) ? aInstanceColorStart : aInstanceColorEnd;\r\n\t#endif\r\n\t#ifdef USE_DASH\r\n\t\tvLineDistance = ( isStart ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\r\n\t#endif\r\n\tfloat aspect = uResolution.x / uResolution.y;\r\n\t\r\n\tvUv = uv;\r\n\tvInstanceSegmentIndex = aInstanceSegmentIndex;\r\n\r\n\tvec3 instanceStart = transformLocalPosition( aInstanceStart , aInstanceSegmentIndex);\r\n\tvec3 instanceEnd =   transformLocalPosition( aInstanceEnd   , aInstanceSegmentIndex);\r\n\t\r\n\t// camera space\r\n\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\r\n\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\r\n\t\r\n\tstart = transformViewPosition( start , aInstanceSegmentIndex);\r\n\tend =   transformViewPosition( end   , aInstanceSegmentIndex);\r\n\r\n\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\r\n\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\r\n\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\r\n\t// perhaps there is a more elegant solution -- WestLangley\r\n\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\r\n\tif ( perspective ) {\r\n\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\r\n\t\t\ttrimSegment( start, end );\r\n\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\r\n\t\t\ttrimSegment( end, start );\r\n\t\t}\r\n\t}\r\n\t\r\n\t// clip space\r\n\tvec4 clipStart = projectionMatrix * start;\r\n\tvec4 clipEnd = projectionMatrix * end;\r\n\r\n\tclipStart = transformProjectedPosition( clipStart , aInstanceSegmentIndex);\r\n\tclipEnd =   transformProjectedPosition( clipEnd   , aInstanceSegmentIndex);\r\n\t\r\n\t// ndc space\r\n\tvec2 ndcStart = clipStart.xy / clipStart.w;\r\n\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\r\n\t\r\n\t// direction\r\n\tvec2 dir = ndcEnd - ndcStart;\r\n\t// account for clip-space aspect ratio\r\n\tdir.x *= aspect;\r\n\tdir = normalize( dir );\r\n\t// perpendicular to dir\r\n\tvec2 offset = vec2( dir.y, - dir.x );\r\n\t// undo aspect ratio adjustment\r\n\tdir.x /= aspect;\r\n\toffset.x /= aspect;\r\n\t// sign flip\r\n\tif ( position.x < 0.0 ) offset *= - 1.0;\r\n\t// endcaps\r\n\tif ( position.y < 0.0 ) {\r\n\t\toffset += - dir;\r\n\t} else if ( position.y > 1.0 ) {\r\n\t\toffset += dir;\r\n\t}\r\n\t// adjust for uLinewidth\r\n\toffset *= uLinewidth;\r\n\t// adjust for clip-space to screen-space conversion // maybe uResolution should be based on viewport ...\r\n\toffset /= uResolution.y;\r\n\t// select end\r\n\tvec4 clip = ( isStart ) ? clipStart : clipEnd;\r\n\t// back to clip space\r\n\toffset *= clip.w;\r\n\tclip.xy += offset;\r\n\tgl_Position = clip;\r\n\tvec4 mvPosition = ( isStart ) ? start : end; // this is an approximation\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <fog_vertex>\r\n\t\r\n\t%- cVertexEnd -%\r\n}"},815:e=>{e.exports=t}},n={};function r(t){if(n[t])return n[t].exports;var o=n[t]={exports:{}};return e[t](o,o.exports,r),o.exports}return r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r(986)})()}));
//# sourceMappingURL=bundle.js.map