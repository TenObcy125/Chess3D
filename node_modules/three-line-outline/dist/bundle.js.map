{"version":3,"sources":["webpack://ThickLine/webpack/universalModuleDefinition","webpack://ThickLine/external {\"root\":\"THREE\",\"amd\":\"three\",\"commonjs\":\"three\",\"commonjs2\":\"three\"}","webpack://ThickLine/webpack/bootstrap","webpack://ThickLine/webpack/runtime/define property getters","webpack://ThickLine/webpack/runtime/hasOwnProperty shorthand","webpack://ThickLine/webpack/runtime/make namespace object","webpack://ThickLine/./src/OutlineMaterial.ts","webpack://ThickLine/./src/OutlineMesh.ts"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__815__","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","Math","PI","_angleThreshold","outline","color","vertexShader","fragmentShader","uniforms","uAngleThresh","uOutline","uColor","Color","angleThreshold","setStyle","this","degrees","Boolean","Number","ShaderMaterial","NULL_VECTOR","Vector3","mesh","outlineMaterial","OutlineMaterial","BufferGeometry","_extractGeometry","geometry","index","_extractIndexed","_extractSoup","vArray","n0Array","n1Array","otherVertArray","g","setAttribute","BufferAttribute","Float32Array","_weldIndexed","attributes","position","weldedIndices","weldedVertices","edges","_extractEdgesFromIndex","sg","BoxBufferGeometry","sm","MeshBasicMaterial","i","length","Mesh","fromArray","forEach","a","b","n0","n1","extract","_index","push","toArray","indexBuffer","positionBuffer","map","weldedVerticesMap","v","c","count","v3","array","round","join","undefined","t","source","faceNormals","av","bv","cv","normal","crossVectors","sub","normalize","edgeFaceMap","halfEdges","offset","curr","next","duplicateMap","f0","f1","isOutline","triangleCount","LineSegments"],"mappings":"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","file":"bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"three\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"three\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ThickLine\"] = factory(require(\"three\"));\n\telse\n\t\troot[\"ThickLine\"] = factory(root[\"THREE\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE__815__) {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__815__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Color, ShaderMaterial } from 'three'\nimport vertexShader from './glsl/outline.vert'\nimport fragmentShader from './glsl/outline.frag'\n\nconst PI_INV = 1 / Math.PI\n\nexport class OutlineMaterial extends ShaderMaterial {\n  constructor(private _angleThreshold = 0, outline = true, color = '#ffffff') {\n    super({\n      vertexShader,\n      fragmentShader,\n      uniforms: {\n        uAngleThresh: { value: 0 },\n        uOutline: { value: 0 },\n        uColor: { value: new Color() },\n      },\n    })\n    this.angleThreshold = _angleThreshold\n    this.outline = outline\n    this.color.setStyle(color)\n  }\n  set angleThreshold(degrees: number) {\n    this._angleThreshold = degrees\n    this.uniforms.uAngleThresh.value = ((degrees / 180) * Math.PI) % Math.PI\n  }\n  get angleThreshold(): number {\n    return this._angleThreshold\n  }\n  set outline(outline: boolean) {\n    this.uniforms.uOutline.value = Number(outline)\n  }\n  get outline(): boolean {\n    return Boolean(this.uniforms.uOutline.value)\n  }\n  get color(): Color {\n    return this.uniforms.uColor.value\n  }\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport {\n  ArrowHelper,\n  BoxBufferGeometry,\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  LineSegments,\n  Mesh,\n  MeshBasicMaterial,\n  Vector3,\n} from 'three'\nimport { OutlineMaterial } from './OutlineMaterial'\n\ninterface IEdge {\n  a: number\n  b: number\n  n0: Vector3\n  n1: Vector3\n}\ninterface IEdgeArrays {\n  vArray: number[]\n  n0Array: number[]\n  n1Array: number[]\n  otherVertArray: number[]\n}\nconst NULL_VECTOR = new Vector3()\nconst WELD_FACTOR = 1000\n\nexport class OutlineMesh extends LineSegments {\n  constructor(mesh: Mesh, outlineMaterial = new OutlineMaterial()) {\n    super(new BufferGeometry(), outlineMaterial)\n    this._extractGeometry(mesh.geometry)\n  }\n\n  private _extractGeometry(geometry: BufferGeometry): void {\n    const { vArray, n0Array, n1Array, otherVertArray } = geometry.index\n      ? this._extractIndexed(geometry)\n      : this._extractSoup(geometry)\n    const g = this.geometry as BufferGeometry\n    g.setAttribute('position', new BufferAttribute(new Float32Array(vArray), 3))\n    g.setAttribute('aN0', new BufferAttribute(new Float32Array(n0Array), 3))\n    g.setAttribute('aN1', new BufferAttribute(new Float32Array(n1Array), 3))\n    g.setAttribute(\n      'aOtherVert',\n      new BufferAttribute(new Float32Array(otherVertArray), 4),\n    )\n  }\n\n  private _extractIndexed(geometry: BufferGeometry): IEdgeArrays {\n    const { weldedIndices, weldedVertices } = this._weldIndexed(\n      geometry.index!,\n      geometry.attributes.position as BufferAttribute,\n    )\n    const edges = this._extractEdgesFromIndex(weldedIndices, weldedVertices)\n    const vArray: number[] = []\n    const n0Array: number[] = []\n    const n1Array: number[] = []\n    const otherVertArray: number[] = []\n\n    const sg = new BoxBufferGeometry(0.1, 0.1, 0.1)\n    const sm = new MeshBasicMaterial({ color: 'red' })\n    for (let i = 0; i < weldedVertices.length / 3; i++) {\n      const m = new Mesh(sg, sm)\n      m.position.fromArray(weldedVertices, i * 3)\n    }\n    edges.forEach(({ a, b, n0, n1 }, i) => {\n      const extract = (index: number, n0: Vector3, n1: Vector3) => {\n        const _index = index * 3\n        n0Array.push(...n0.toArray())\n        n1Array.push(...n1.toArray())\n        for (let i = 0; i < 3; i++) vArray.push(weldedVertices[_index + i])\n      }\n      extract(a, n0, n1)\n      extract(b, n0, n1)\n      for (let i = 0; i < 3; i++) otherVertArray.push(weldedVertices[b * 3 + i])\n      otherVertArray.push(0)\n      for (let i = 0; i < 3; i++) otherVertArray.push(weldedVertices[a * 3 + i])\n      otherVertArray.push(1)\n    })\n    return { vArray, n0Array, n1Array, otherVertArray }\n  }\n\n  private _weldIndexed(\n    indexBuffer: BufferAttribute,\n    positionBuffer: BufferAttribute,\n  ) {\n    const map: Record<string, number> = {}\n    const weldedVerticesMap: Record<number, number> = {}\n    const weldedVertices: number[] = []\n    const weldedIndices: number[] = []\n\n    for (let v = 0, c = 0; v < positionBuffer.count; v++) {\n      const v3 = v * 3\n      const xyz = [\n        positionBuffer.array[v3],\n        positionBuffer.array[v3 + 1],\n        positionBuffer.array[v3 + 2],\n      ].map((v) => Math.round(v * WELD_FACTOR))\n      const key = xyz.join(':')\n      if (map[key] === undefined) {\n        map[key] = c++\n        weldedVertices.push(\n          positionBuffer.array[v3],\n          positionBuffer.array[v3 + 1],\n          positionBuffer.array[v3 + 2],\n        )\n      }\n      weldedVerticesMap[v] = map[key]\n    }\n    for (let t = 0; t < indexBuffer.count; t += 3)\n      for (let i = 0; i < 3; i++) {\n        const source = indexBuffer.array[t + i]\n        weldedIndices.push(weldedVerticesMap[source])\n      }\n\n    return { weldedVertices, weldedIndices }\n  }\n\n  private _extractEdgesFromIndex(\n    indexBuffer: number[],\n    positionBuffer: number[],\n  ): IEdge[] {\n    const faceNormals: Vector3[] = []\n    const av = new Vector3()\n    const bv = new Vector3()\n    const cv = new Vector3()\n\n    for (let t = 0; t < indexBuffer.length; ) {\n      const normal = new Vector3()\n      av.fromArray(positionBuffer, indexBuffer[t++] * 3)\n      bv.fromArray(positionBuffer, indexBuffer[t++] * 3)\n      cv.fromArray(positionBuffer, indexBuffer[t++] * 3)\n      normal.crossVectors(bv.sub(av), cv.sub(av))\n      faceNormals.push(normal.normalize())\n    }\n\n    const edgeFaceMap: Record<number, Record<number, number>> = {}\n    const halfEdges: [number, number][] = []\n\n    for (let t = 0; t < indexBuffer.length / 3; t++) {\n      const offset = t * 3\n      for (let curr = 0; curr < 3; curr++) {\n        const next = (curr + 1) % 3\n        const a = indexBuffer[offset + curr]\n        const b = indexBuffer[offset + next]\n        if (!edgeFaceMap[a]) edgeFaceMap[a] = {}\n        edgeFaceMap[a][b] = t\n        halfEdges.push([a, b])\n      }\n    }\n\n    const edges: IEdge[] = []\n    const duplicateMap: Record<number, Record<number, boolean>> = {}\n\n    halfEdges.forEach(([a, b]) => {\n      if (!duplicateMap[a]) duplicateMap[a] = {}\n      if (!duplicateMap[b]) duplicateMap[b] = {}\n\n      if (duplicateMap[a][b]) return\n\n      const f0 = edgeFaceMap[a][b]\n      const f1 = edgeFaceMap[b][a]\n\n      const isOutline = f0 !== undefined && f1 !== undefined\n      const n0 = isOutline ? faceNormals[f0] : NULL_VECTOR\n      const n1 = isOutline ? faceNormals[f1] : NULL_VECTOR\n\n      edges.push({ a, b, n0, n1 })\n      duplicateMap[a][b] = true\n      duplicateMap[b][a] = true\n    })\n\n    return edges\n  }\n\n  private _extractSoup(geometry: BufferGeometry): IEdgeArrays {\n    const triangleCount = geometry.attributes.position.count\n    const edgeMap = {}\n\n    for (let t = 0; t < triangleCount; t++) {\n      geometry.attributes.position.array\n    }\n    const vArray: number[] = []\n    const n0Array: number[] = []\n    const n1Array: number[] = []\n    const otherVertArray: number[] = []\n    // const weldedVertices: number[] = []\n\n    return { vArray, n0Array, n1Array, otherVertArray }\n  }\n}\n"],"sourceRoot":""}